{
  "name": "streamline",
  "description": "Asynchronous Javascript for dummies",
  "version": "0.4.5",
  "engines": {
    "node": ">=0.6.0"
  },
  "dependencies": {},
  "author": {
    "name": "Bruno Jouhier"
  },
  "directories": {
    "lib": "./lib",
    "bin": "./bin"
  },
  "main": "index.js",
  "bin": {
    "_coffee": "bin/_coffee",
    "_node": "bin/_node",
    "coffee-streamline": "bin/coffee-streamline",
    "node-streamline": "bin/node-streamline"
  },
  "readme": "# streamline.js\n\n`streamline.js` is a language tool to simplify asynchronous Javascript programming.\n\nInstead of writing hairy code like:\n\n```javascript\nfunction archiveOrders(date, cb) {\n  db.connect(function(err, conn) {\n    if (err) return cb(err);\n    conn.query(\"select * from orders where date < ?\", [date], function(err, orders) {\n      if (err) return cb(err);\n      helper.each(orders, function(order, next) {\n        conn.execute(\"insert into archivedOrders ...\", [order.id, ...], function(err) {\n          if (err) return cb(err);\n          conn.execute(\"delete from orders where id=?\", [order.id], function(err) {\n            if (err) return cb(err);\n            next();\n          });\n        });\n      }, function() {\n        console.log(\"orders have been archived\");\n        cb();\n      });\n    });\n  });\n}\n```\n\nyou write:\n\n```javascript\nfunction archiveOrders(date, _) {\n  var conn = db.connect(_);\n  conn.query(\"select * from orders where date < ?\", [date], _).forEach_(_, function(_, order) {\n    conn.execute(\"insert into archivedOrders ...\", [order.id, ...], _);\n    conn.execute(\"delete from orders where id=?\", [order.id], _);\n  });\n  console.log(\"orders have been archived\");\n}\n```\n\nand streamline transforms the code and takes care of the callbacks!\n\nNo flow control APIs to learn! You just have to follow a simple rule:\n\n> Replace all callbacks by an underscore and write your code as if all functions were synchronous.\n\nStreamline is not limited to a subset of Javascript. \nYou can use all the features of Javascript in your asynchronous code: conditionals, \nloops, `try/catch/finally` blocks, anonymous functions, chaining, `this`, etc. \n\nStreamline also provides _futures_, and asynchronous variants of the EcmaScript 5 array functions (`forEach`, `map`, etc.).\n\n# Installation\n\nNPM, of course: \n\n```sh\nnpm install streamline -g\n```\n\nThe `-g` option installs streamline _globally_.\nYou can also install it _locally_, without `-g` but then the `_node` and `_coffee` \ncommands will not be in your default PATH.\n\nNote: If you encounter a permission error when installing on UNIX systems, you should retry with `sudo`. \n\nIf you want to use the _fibers_ option (see below), you must also install the fibers library:\n\n```sh\nnpm install fibers [-g]\n```\n\n# Hello World\n\nStreamline modules have `._js` or `._coffee` extensions and you run them with the `_node` or `_coffee` \nloader.\n\nJavascripters:\n\n``` sh\n$ cat > hello._js\nconsole.log('hello ...');\nsetTimeout(_, 1000);\nconsole.log('... world');\n^D\n$ _node hello\n```\n\nCoffeescripters:\n\n``` sh\n$ cat > hello._coffee\nconsole.log 'hello ...'\nsetTimeout _, 1000\nconsole.log '... world'\n^D\n$ _coffee hello\n```\n\nYou can also create standalone shell utilities:\n\n``` sh\n$ cat > hello.sh\n#!/usr/bin/env _node\nconsole.log('hello ...');\nsetTimeout(_, 1000);\nconsole.log('... world');\n^D\n$ ./hello.sh\n```\n\nor:\n\n``` sh\n$ cat > hello.sh\n#!/usr/bin/env _coffee\nconsole.log 'hello ...'\nsetTimeout _, 1000\nconsole.log '... world'\n^D\n$ ./hello.sh\n```\n\n# Compiling and writing loaders\n\nYou can also set up your code so that it can be run directly with `node` or `coffee.\nYou have two options here:\n\nThe first one is to compile your source with `_node -c` or `_coffee -c`:\n\n``` sh\n$ _node -c .\n```\n\nThis command compiles all the `*._js` and `*._coffee` source files in the current directory and its sub-directories. It generates `*.js` files that you can run directly with `node`.\n\nThe second one is to create your own loader with the `register` API. See the [loader example](https://github.com/Sage/streamlinejs/blob/master/examples/loader/loader.md) for details.\n\nCompiling will give you the fastest startup time because node will directly load the compiled `*.js` files but the `register` API has a `cache` option which comes close and the loader saves you a compilation pass.\n\n# Browser-side use\n\nYou have three options to use streamline in the browser:\n\n* The first one is to compile the source with `_node -c`. The compiler generates vanilla Javascript code that you can load with `<script>` directives in an HTML page. See the [flows unit test](https://github.com/Sage/streamlinejs/blob/master/test/common/flows-test.html) for an example.\n* You can also transform the code in the browser with the `transform` API. See the [streamlineMe example](https://github.com/Sage/streamlinejs/blob/master/examples/streamlineMe).\n* A third option is to use the [streamline-require](https://github.com/Sage/streamline-require) infrastructure. This is a very efficient browser-side implementation of `require` that lets you load streamlined modules as well as vanilla Javascript modules in the browser. \n\n# Generation options\n\nStreamline gives you the choice between generating regular callback-based asynchronous code, \ngenerating code that takes advantage of the [fibers library](https://github.com/laverdet/node-fibers), \nor generating code for [JavaScript generators](https://developer.mozilla.org/en/New_in_JavaScript_1.7#Generators).\n\nThe _callback_ option produces code that does not have any special runtime dependencies. \n\nThe _fibers_ option produces simpler code but requires that you install \nthe fibers library (easy: `npm install fibers`). \nThis option gives superior development experience: line numbers and comments are preserved in the transformed code; \nyou can step with the debugger through asynchronous calls without having to go through complex callbacks, etc.\n\nThe _fibers_ option can be activated by passing the `--fibers` option to the `_node` command or by \nsetting the `fibers` option when registering streamline \n(see the `streamline.register(options)` function.\n\nThe _generators_ option is more experimental (but rather solid as it passes all unit tests). \nIt produces code that is similar to the _fibers_ option, although slightly more complex. \nLike the _fibers_ option, it preserves line numbers and comments. \nThis option does _not_ yet work in node.js because V8 does not currently support generators but it works in Firefox and in [luvmonkey](https://github.com/creationix/luvmonkey). \nIt should work, with minor tweaks, in future versions of V8 that may implement [Harmony generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators).\n \n# Interoperability with standard node.js code\n\nYou can call standard node functions from streamline code. For example the `fs.readFile` function:\n\n```javascript\nfunction lineCount(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n```\nYou can also call streamline functions as if they were standard node functions. For example, the `lineCount` function defined above can be called as follows from non-streamlined modules:\n\n```javascript\nlineCount(\"README.md\", function(err, result) {\n  if (err) return console.error(\"ERROR: \" + err.message);\n  console.log(\"README has \" + result + \" lines.\");\n});\n```\n\nAnd you can mix streamline functions, classical callback based code and synchrononous functions in the same file. \nStreamline only transforms the functions that have the special `_` parameter. \n\nNote: this works with all transformation options. \nEven if you use the _fibers_ option, you can seamlessly call standard callback based node APIs \nand the asynchronous functions that you create with streamline have the standard node callback signature.\n\n# Futures\n\nStreamline provides _futures_, a powerful feature that lets you parallelize I/O operations in a very\nsimple manner.\n\nIf you omit the callback (or pass a `null` callback) when calling a streamline function, the function will execute synchronously and return a _future_. The _future_ is just an asynchronous function that you can call later to obtain a result. Here is an example:\n\n```javascript\nfunction countLines(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n\nfunction compareLineCounts(path1, path2, _) {\n  // parallelize the two countLines operations\n  var n1 = countLines(path1);\n  var n2 = countLines(path2);\n  // get the results and diff them\n  return n1(_) - n2(_);\n}\n```\n\nIn this example, `countLines` is called twice without `_` parameter. These calls start the `fs.readFile` asynchronous operations and return immediately two _futures_ (`n1` and `n2`). The `return` statement retrieves the results with `n1(_)` and `n2(_)` calls and computes their difference. \n\nFutures are very flexible. In the example above, the results are retrieved from the same function, but you can also pass futures to other functions, store them in objects, call them to get the results from a different module, etc. You can also have several readers on the same future. \n\nSee the [futures](https://github.com/Sage/streamlinejs/wiki/Futures) wiki page for details.\n\nThe [flows module](https://github.com/Sage/streamlinejs/blob/master/lib/util/flows.md) contains utilities to deal with futures: \n`flows.collect` to wait on an array of futures and `flows.funnel` to limit the number of concurrent operations.\n\n# Asynchronous Array functions\n\nStreamline extends the Array prototype with asynchronous variants of the EcmaScript 5 `forEach`, `map`, `filter`, `reduce`, ... functions. These asynchronous variants are postfixed with an underscore and they take an extra `_` argument (their callback too), but they are otherwise similar to the standard ES5 functions. Here is an example with the `map_` function:\n\n``` javascript\nfunction dirLines(dir, _) {\n  return fs.readdir(dir, _).map_(_, function(_, file) {\n    return fs.readFile(dir + '/' + file, 'utf8', _).split('\\n').length;\n  });\n}\n```\n\nParallelizing loops is easy: just pass the number of parallel operations as second argument to the call:\n\n``` javascript\nfunction dirLines(dir, _) {\n  // process 8 files in parallel\n  return fs.readdir(dir, _).map_(_, 8, function(_, file) {\n    return fs.readFile(dir + '/' + file, 'utf8', _).split('\\n').length;\n  });\n}\n```\n\nIf you don't want to limit the level of parallelism, just pass `-1`.\n\nSee the documentation of the [builtins module](https://github.com/Sage/streamlinejs/blob/master/lib/compiler/builtins.md) for details.\n\n# Exception Handling\n\nStreamline lets you do your exception handling with the usual `try/catch` construct. The `finally` clause is also supported.\n\nStreamline overrides the `ex.stack` getter to give you the stack of streamline calls rather than the last callback stack. You can still get the native callback stack trace with `ex.rawStack`.\n\nException handling also works with futures.\nIf a future throws an exception before you try to read its result, the exception will be memorized by the future and you will get it at the point where your try to read the result. \nFor example:\n\n``` javascript\ntry {\n  var n1 = countLines(badPath);\n  var n2 = countLines(goodPath);\n  setTimeout(_, 1000); // n1 fails, exception is memorized\n  return n1(_) - n2(_); // exception is thrown by n1(_) expression.\n} catch (ex) {\n  console.error(ex.stack); // exception caught here\n}\n```\n\n# Stream Wrappers\n\nStreamline also provides _stream wrappers_ that simplify stream programming. The [streams module](https://github.com/Sage/streamlinejs/blob/master/lib/streams/server/streams.md) contains:\n\n* a generic `ReadableStream` wrapper with an asynchronous `stream.read(_[, len])` method.\n* a generic `WritableStream` wrapper with an asynchronous `stream.write(_, buf[, encoding])` method.\n* wrappers for HTTP and TCP request and response objects (client and server).\n\n# Examples\n\nThe [diskUsage](https://github.com/Sage/streamlinejs/blob/master/examples/diskUsage) examples shows an asynchronous directory traversal that computes disk usage.\nYou can run it as follows:\n\n```sh\n_node streamline/examples/diskUsage/diskUsage\n```\n\nThe `diskUsage2` example is a faster variant that parallelizes I/O operations with futures. \nYou'll also find CoffeeScript versions of these examples.\n\n# Online demo\n\nYou can see how streamline transforms the code by playing with the [online demo](http://sage.github.com/streamlinejs/examples/streamlineMe/streamlineMe.html).\n\nIf you are curious, you can also play with the [generators demo - Firefox only](http://sage.github.com/streamlinejs/examples/streamlineMe/yieldMe.html).\n\n# Troubleshooting\n\nRead the [FAQ](https://github.com/Sage/streamlinejs/blob/master/FAQ.md).\n\nIf you don't find your answer in the FAQ, post to the [mailing list](http://groups.google.com/group/streamlinejs), or file an issue in [GitHub's issue tracking](https://github.com/Sage/streamlinejs/issues).\n\n# Related Packages\n\nThe following packages use streamline.js:\n\n* [streamline-require](https://github.com/Sage/streamline-require): a light and efficient _require_ infrastructure for modules in the browser.\n* [streamline-pdfkit](https://github.com/Sage/streamline-pdfkit): a fork of [pdfkit](https://github.com/devongovett/pdfkit) in which all the sync calls have been eliminated.\n* [streamline-zip](https://github.com/Sage/streamline-zip): a fork of [node-native-zip](https://github.com/janjongboom/node-native-zip) with async deflate.\n\n\n# Resources\n\nThe API is documented [here](https://github.com/Sage/streamlinejs/blob/master/API.md).\n\nThe [wiki](https://github.com/Sage/streamlinejs/wiki) give more information on advanced topics.\n\nFor support and discussion, please join the [streamline.js mailing list](http://groups.google.com/group/streamlinejs).\n\n# Credits\n\nSee the [AUTHORS](https://github.com/Sage/streamlinejs/blob/master/AUTHORS) file.\n\nSpecial thanks to Marcel Laverdet who contributed the _fibers_ implementation.\n\n# License\n\nThis work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\n",
  "contributors": [
    {
      "name": "Bruno Jouhier",
      "email": "bruno.jouhier@sage.com"
    },
    {
      "name": "Preston Guillory",
      "email": "pguillory@gmail.com"
    },
    {
      "name": "Will Conant",
      "email": "will.conant@gmail.com"
    },
    {
      "name": "Aseem Kishore",
      "email": "aseem.kishore@gmail.com"
    },
    {
      "name": "Daniel Ennis",
      "email": "aikar@aikar.co"
    },
    {
      "name": "Marcel Laverdet",
      "email": "marcel@laverdet.com",
      "url": "https://github.com/laverdet/"
    },
    {
      "name": "Evan Worley"
    },
    {
      "name": "anodos",
      "url": "https://github.com/anodos"
    },
    {
      "name": "Alan Gutierrez",
      "email": "alan@prettyrobots.com"
    }
  ],
  "_id": "streamline@0.4.5",
  "_from": "streamline@~0.4.0"
}
